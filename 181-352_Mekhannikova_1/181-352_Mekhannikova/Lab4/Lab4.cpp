/*
ЛАБОРАТОРНАЯ №4
ФУНКЦИИ
*/

#include "stdafx.h"
#include <iostream>


//1. ОПРЕДЕЛЕНИЕ И СИНТАКСИС
//фрагмент кода, который имеет своё собственное имя (идентификатор), 
//входные-выходные параметры (правила вызова)

//ОБЪЯВЛЕНИЕ ФУНКЦИИ - фактически, один её заголовок с именем и списком параметров
//ОПРЕДЕЛЕНИЕ ФУНКЦИИ - заголовок + {тело функции}

//синтаксис объявления
//возвращаемый_тип имя_функции(тип1 имя_параметра, тип2 имя_параметра_2, ...)

//функция должна быть ОБЪЯВЛЕНА до её первого использования, те
//заголовок функции с параметрами и именем должен быть прописан
//до момента первого вызова
//так как компилятор проходит текст лишь однажды, и например, найдя функцию в конце,
//он не возвратится в начало и во всём тексте вызовы функции пометит как ошибки

//синтаксис вызова (использования) функции
//имя_функции(параметр1, параметр2, ...)
//переменная = имя_функции(параметр1, параметр2, ...)

//использование функции удобно, т.к. позволяет многократно использовать
//один и тот же фрагмент кода не повторяя его целиком, а только назвав по имени 

//если функция должна возвращать выходное значение, оно возвращается через return

double function_add(double p1, double p2)
{
	std::cout << "Функция function_add2() return value возвращает значение" << std::endl;
	return p1 + p2;
}

void function_add2nr(double p1, double p2)
{
	std::cout << "Функция function_add2() does not return value не возвращает значение" << std::endl;
	return;//в случае void значений не возвращается
}
int main()
{
	double c = function_add(10.5, 20.5);//функцию/, возвращающее значение, можно вызвать и так
	function_add(10.5, 20.5);//...и так
	std::сout << "c = function_add2(10.5, 20.5) = " << c << std::endl;
	function_add2nr(10.5, 20.5);//функцию, не возвращающую значение - вызывать без присваивания

	getchar();
	return 0;
}

