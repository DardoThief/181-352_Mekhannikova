#include "stdafx.h"
#include <iostream>
using namespace std;
int main()
// for - оператор цикла с отсчётом
//
//for(целочисл_переменная; условие_продолжения; повторяемое_действие)
//{
// действия, повторяемые, пока (условие_продолжения == true)
//}
// while(условие) - действия выполняются до тех пор, пока условие == true
//{ // условие проверяется ПЕРЕД каждым заходом в цикл

//}
// while - цикл с пред - условием, т.е.сначала проверяется условие, затем выполняется действие

// do-while - цикл с постусловием
// do
//{

//}
/*
continue; // переход на следующую ИТЕРАЦИЮ

break; // выход из цикла
*/
{
for (;;)
{
	if (k >= 10)
	{
		break;
	}
	std::cout << "arr[k] = " << arr[k] << std::endl;
	k++;
}
// также возможен такой вариант
for (int i = 0, j = 5; // через "," можно перечислить сколько угодно операторов
	i + j < 10, j < 10; // ???
	i++, j = j + 2, std::cout << "i=" << i << '\t' << "j = " << j << std::endl) // через "," можно перечислить сколько угодно операторов
{
	// действия, повторяемые, пока i + j < 10
}
// тернарный оператор (сокращённая запись)
// (лог_выр) ? (операторы если true) : (операторы если false)
// переписываем первый пример if

(d == 0) ?
(std::cout << "d == 0" << std::endl) :
	(
	(d > 0) ?
		(std::cout << "d > 0" << std::endl) :
		(std::cout << "d < 0" << std::endl)
		);

/*
Несмотря на то, что программист не прописыват вручную вызов конструктора и диструктора, 
они всё равно срабатывают: компилятор при анализе текста отслеживает, когда объект 
появляется и когда он исчезает
и автоматически не явно для программиста подставляет вызов конструктора в воде 
*/

class vehicle
{
public:
		vehicle(/*могут быть входные параметры*/)//конструктор
		{
			cout << "constructor vehicle" << endl;
			return;
		}

		~vehicle(/*НЕ могут быть входные параметры!*/) //деструктор
		{
			cout << "~constructor of vehicle" << endl;
		return;
		}
};

//конструктором и деструктором автоматицески назначается функция,
//имеющая то же имя, что и класс (деструктор с "~")

//конструктор должен быть public

//конструктор не может возвращать параметры, но может иметь входные параметры
//деструктор не может иметь ни входных, ни выходных

/*
5. СТРУКТУРЫ
// Несмотря на то, что в литературе структура как правило хранит только данные,
// на самом деле это то же самое, что и класс. Единственное отличие - поля по
// умолчанию public

struct some_structure {

}
*/
/*6. ОПРЕДЕЛЕНИЕ МЕТОДОВ СНАРУЖИ КЛАССА
в объявлении класса остаётся объявление (заголовок) метода
тело (реализация) метода переносится наружу вместе с копией заголовка
к заголовку реализации добавляется "имя_класса::"

bool vehicle::check_regnumber()
*/

