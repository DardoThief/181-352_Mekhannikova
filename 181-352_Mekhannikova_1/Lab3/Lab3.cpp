//лабораторная работа 3
//указатели - это переменная, хранящая адрес другой переменной в оперативной памяти
#include <iostream>//угловые скобки <> - поиск файла в списке системных каталогов среды
#include "stdafx.h"//в первую очередь искать рядом с проектом

int some_global_varible;//переменные объявлять можно до main
int main(){//обязательная точка входа в приложение
int a;
a = 321;
double dbl = 10.005;
//1. синтаксис объявления указателей "тип-данных" имя_указателя;
int * ptr_int;
ptr_int = &a;//оператор амперсанд & - оператор получения адреса
double * ptr_dbl = &dbl;

//2. Размер указателя
//все указатели всегда одной и той же разрядности (размера)
//каким бы ни был огромным тип данных (строка, объект, массив)
//указатель на него всегда будет занимать 4/8 байт, что и является основным
//преимуществом указателей std::cout << "int pointer size = " << sizeof(ptr_int) << std::endl;
std::cout << "int pointer size = " << sizeof(ptr_int) << std::endl;
std::cout << "double pointer size = " << sizeof(ptr_dbl) << std::endl;
std::cout << "char pointer size = " << sizeof(char*) << std::endl;
std::cout << "long long pointer size = " << sizeof(long long *) << std::endl;
std::cout << "bool pointer size = " << sizeof(bool *) << std::endl;

//3. Содержимое указателя
std::cout << "ptr_int = " << ptr_int << std::endl;
std::cout << "ptr_dbl = " << ptr_dbl << std::endl;

//в случае сборки на х64 размер указателей будет 8 байт (64-разрядная адресация)
//оператор разыменования указателей: чтобы получить значение, хранящееся по данному указателю, нужно ещё раз применять оператор *
a = *ptr_int; //получить обратно значение а
/*
int b = 0;
b = a;
b = *ptr_int; //получить обратно значение а, аналогично b = a
*/
std::cout << std::endl << "*ptr_int = " << std::dec << *ptr_int << std::endl;
std::cout << "* ptr_dbl = " << *ptr_dbl << std::endl;

int arr1D[10] = { 1, 50, 11, 12, 101 }; // одномерный массив из 10 целых знаковых чисел
int arr2D[3][3] = { { 11, 12, 13 },
{ 21, 22, 23 },
{ 31, 32, 33 } }; // одномерный массив из 10 целых знаковых чисел

//4. Печать области памяти
for (int *i = &a - 50;
	i < &a + 50;
	i++)
{
	std::cout <<
		"0x" << // шестнадцатиразрядные числа принято оформлять с 0x, особенно адреса ОП
		i << //печатается содержимое указателя
		'\t' << //escape-символ кодирующий табуляцию
		std::endl;
	// рядом печатается 0xадрес и значение
}
//5. Указатели и массивы
//5.1 просто имя без массива без скобок имеет тип указателя
//имя двумерного массива имеет тип указателя на указатель
//В записи double arr1D[n] arr1D имеет тип (double*)
//В записи double arr2D[m][n] arr2D имеет тип (double**)
//5.2 Обращаясь как arr2D[m] можно получить указатель на одномерный массив-строку
//5.3 Оператор [] фактически прибавляет индекс к указателю массива: 
//arr1D[i] то же самое, что и *(arr1D + i)
//по сути, квадратные скобки работают как разыменование и смещение
std::cout << "arr1D[3] = *(arr1D+3) = " << *(arr1D + 3) << std::endl;
std::cout << "arr2D[2][2] = *(*(arr2D+2)+2) = " << *(*(arr2D + 2) + 2) << std::endl;

getchar();
return 0;
}

